#!/usr/bin/env python3
"""
Test Graph Connectivity - Verify the investigation graph forms one giant connected component
following the proper ontology with all nodes connected through edges.
"""

import sys
import os
from typing import Set, Dict, List

# Add twitterexplorer to the path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'twitterexplorer'))

def test_graph_connectivity_and_ontology():
    """Test that the investigation graph properly implements the ontology as one connected component"""
    print("=== Testing Graph Connectivity and Ontology Implementation ===")
    
    try:
        from investigation_graph import InvestigationGraph
        from graph_aware_llm_coordinator import GraphAwareLLMCoordinator
        from llm_client import get_litellm_client
        
        # Create a test graph and populate it with realistic investigation
        graph = InvestigationGraph()
        
        print("\n[TEST 1] Testing Basic Graph Construction and Connectivity")
        print("-" * 50)
        
        # Create the root analytic question (this should be the root of the component)
        analytic_q = graph.create_analytic_question_node("Find information about UFO whistleblower claims")
        print(f"[OK] Created AnalyticQuestion node (root): {analytic_q.id}")
        
        # Create investigation questions that should connect to the analytic question
        inv_q1 = graph.create_investigation_question_node("What are the specific claims made?", analytic_q.id)
        inv_q2 = graph.create_investigation_question_node("Who are the critics and skeptics?", analytic_q.id)
        print(f"[OK] Created 2 InvestigationQuestion nodes")
        
        # Connect investigation questions to analytic question with MOTIVATES edges
        edge1 = graph.create_edge(analytic_q, inv_q1, "MOTIVATES", {"relevance": 0.9})
        edge2 = graph.create_edge(analytic_q, inv_q2, "MOTIVATES", {"relevance": 0.8})
        print(f"[OK] Created MOTIVATES edges from AnalyticQuestion to InvestigationQuestions")
        
        # Create search queries that operationalize the investigation questions
        search1 = graph.create_search_query_node("search.php", {"query": "UFO whistleblower claims"})
        search2 = graph.create_search_query_node("search.php", {"query": "UFO whistleblower debunk"})
        print(f"[OK] Created 2 SearchQuery nodes")
        
        # Connect searches to investigation questions with OPERATIONALIZES edges
        edge3 = graph.create_edge(inv_q1, search1, "OPERATIONALIZES", {})
        edge4 = graph.create_edge(inv_q2, search2, "OPERATIONALIZES", {})
        print(f"[OK] Created OPERATIONALIZES edges from InvestigationQuestions to SearchQueries")
        
        # Create data points generated by searches
        data1 = graph.create_data_point_node("Whistleblower claims about craft", {"source": "tweet1"})
        data2 = graph.create_data_point_node("Skeptical analysis of claims", {"source": "tweet2"})
        print(f"[OK] Created 2 DataPoint nodes")
        
        # Connect data points to searches with GENERATES edges
        edge5 = graph.create_edge(search1, data1, "GENERATES", {})
        edge6 = graph.create_edge(search2, data2, "GENERATES", {})
        print(f"[OK] Created GENERATES edges from SearchQueries to DataPoints")
        
        # Create insights from data points
        insight1 = graph.create_insight_node("Claims lack physical evidence", "critical_finding")
        print(f"[OK] Created Insight node")
        
        # Connect insights to data points with SUPPORTS edges
        edge7 = graph.create_edge(data1, insight1, "SUPPORTS", {})
        edge8 = graph.create_edge(data2, insight1, "SUPPORTS", {})
        print(f"[OK] Created SUPPORTS edges from DataPoints to Insights")
        
        # Create emergent question from insights
        emergent_q = graph.create_emergent_question_node(
            "Why no physical evidence presented?", 
            "Emerged from contradiction in claims"
        )
        print(f"[OK] Created EmergentQuestion node")
        
        # Connect emergent question to insights with SPAWNS edge
        edge9 = graph.create_edge(insight1, emergent_q, "SPAWNS", {})
        print(f"[OK] Created SPAWNS edge from Insight to EmergentQuestion")
        
        # Connect emergent question back to investigation flow
        edge10 = graph.create_edge(emergent_q, inv_q1, "MOTIVATES", {"priority": 0.7})
        print(f"[OK] Created MOTIVATES edge from EmergentQuestion back to InvestigationQuestion")
        
        print("\n[TEST 2] Verifying Graph Connectivity")
        print("-" * 50)
        
        # Test that all nodes are reachable from the root (analytic question)
        def find_connected_component(graph, start_node_id):
            """Find all nodes in the connected component containing start_node"""
            visited = set()
            to_visit = [start_node_id]
            
            while to_visit:
                current = to_visit.pop()
                if current in visited:
                    continue
                    
                visited.add(current)
                
                # Add all connected nodes (both directions)
                for edge in graph.get_outgoing_edges(current):
                    if edge.target_id not in visited:
                        to_visit.append(edge.target_id)
                        
                for edge in graph.get_incoming_edges(current):
                    if edge.source_id not in visited:
                        to_visit.append(edge.source_id)
            
            return visited
        
        # Find the connected component starting from the analytic question
        connected_component = find_connected_component(graph, analytic_q.id)
        total_nodes = len(graph.nodes)
        connected_nodes = len(connected_component)
        
        print(f"Total nodes in graph: {total_nodes}")
        print(f"Nodes in connected component from root: {connected_nodes}")
        print(f"Connectivity: {connected_nodes}/{total_nodes} = {100*connected_nodes/total_nodes:.1f}%")
        
        if connected_nodes == total_nodes:
            print("[PASS] PASS: All nodes form ONE GIANT CONNECTED COMPONENT")
        else:
            print("[FAIL] FAIL: Graph has disconnected nodes!")
            disconnected = set(graph.nodes.keys()) - connected_component
            for node_id in disconnected:
                node = graph.nodes[node_id]
                print(f"  - Disconnected node: {node.node_type} ({node_id})")
        
        print("\n[TEST 3] Verifying Ontology Structure")
        print("-" * 50)
        
        # Verify edge types follow the ontology
        expected_edge_types = {
            "MOTIVATES",      # AnalyticQuestion → InvestigationQuestion
            "OPERATIONALIZES", # InvestigationQuestion → SearchQuery
            "GENERATES",      # SearchQuery → DataPoint
            "SUPPORTS",       # DataPoint → Insight
            "SPAWNS",         # Insight → EmergentQuestion
            "ANSWERS"         # Various → InvestigationQuestion
        }
        
        actual_edge_types = set(edge.edge_type for edge in graph.edges)
        print(f"Expected edge types: {expected_edge_types}")
        print(f"Actual edge types: {actual_edge_types}")
        
        valid_edges = actual_edge_types.issubset(expected_edge_types)
        if valid_edges:
            print("[PASS] PASS: All edge types follow the ontology")
        else:
            invalid = actual_edge_types - expected_edge_types
            print(f"[FAIL] FAIL: Invalid edge types found: {invalid}")
        
        # Verify node types follow the ontology
        expected_node_types = {
            "AnalyticQuestion",
            "InvestigationQuestion", 
            "SearchQuery",
            "DataPoint",
            "Insight",
            "EmergentQuestion"
        }
        
        actual_node_types = set(node.node_type for node in graph.nodes.values())
        print(f"\nExpected node types: {expected_node_types}")
        print(f"Actual node types: {actual_node_types}")
        
        valid_nodes = actual_node_types.issubset(expected_node_types)
        if valid_nodes:
            print("[PASS] PASS: All node types follow the ontology")
        else:
            invalid = actual_node_types - expected_node_types
            print(f"[FAIL] FAIL: Invalid node types found: {invalid}")
        
        print("\n[TEST 4] Testing Graph Traversal Methods")
        print("-" * 50)
        
        # Test get_disconnected_threads method
        threads = graph.get_disconnected_threads()
        if len(threads) <= 1:
            print(f"[PASS] PASS: Graph has {len(threads)} thread(s) - forms single component")
        else:
            print(f"[FAIL] FAIL: Graph has {len(threads)} disconnected threads")
            for i, thread in enumerate(threads):
                print(f"  Thread {i+1}: {len(thread)} nodes")
        
        # Test that analytic question is connected to the main component
        analytic_connections = graph.get_connected_nodes(analytic_q.id)
        print(f"\nAnalytic question has {len(analytic_connections)} direct connections")
        
        # Verify hierarchical structure
        inv_questions = graph.get_nodes_by_type("InvestigationQuestion")
        searches = graph.get_nodes_by_type("SearchQuery")
        data_points = graph.get_nodes_by_type("DataPoint")
        insights = graph.get_nodes_by_type("Insight")
        emergent = graph.get_nodes_by_type("EmergentQuestion")
        
        print(f"\nOntology hierarchy:")
        print(f"  AnalyticQuestion: 1 (root)")
        print(f"  |-- InvestigationQuestions: {len(inv_questions)}")
        print(f"  |   |-- SearchQueries: {len(searches)}")
        print(f"  |   |   |-- DataPoints: {len(data_points)}")
        print(f"  |   |   |   |-- Insights: {len(insights)}")
        print(f"  |-- EmergentQuestions: {len(emergent)}")
        
        print("\n[TEST 5] Testing Coordinator Integration")
        print("-" * 50)
        
        # Test that coordinator properly maintains connectivity
        # Note: This would need a valid API key to fully test
        print("Testing coordinator graph updates...")
        
        # Simulate coordinator updates
        from graph_aware_llm_coordinator import StrategicDecision
        decision = StrategicDecision(
            decision_type="gap_filling",
            reasoning="Testing connectivity",
            searches=[{
                "endpoint": "search.php",
                "parameters": {"query": "test"},
                "reasoning": "Test search"
            }],
            expected_outcomes=["Test outcome"]
        )
        
        # Create a coordinator with the graph
        coordinator = GraphAwareLLMCoordinator(None, graph)  # None for LLM client in test
        
        # Update graph with decision (this should maintain connectivity)
        initial_nodes = len(graph.nodes)
        coordinator._update_graph_with_decision(decision)
        new_nodes = len(graph.nodes)
        
        print(f"Nodes before coordinator update: {initial_nodes}")
        print(f"Nodes after coordinator update: {new_nodes}")
        print(f"New nodes created: {new_nodes - initial_nodes}")
        
        # Verify new nodes are connected
        new_component = find_connected_component(graph, analytic_q.id)
        if len(new_component) == len(graph.nodes):
            print("[PASS] PASS: Coordinator maintains graph connectivity")
        else:
            print("[FAIL] FAIL: Coordinator created disconnected nodes")
        
        print("\n" + "="*60)
        print("FINAL ASSESSMENT:")
        print("="*60)
        
        all_connected = (connected_nodes == total_nodes)
        valid_ontology = valid_edges and valid_nodes
        single_component = len(threads) <= 1
        coordinator_maintains = len(new_component) == len(graph.nodes)
        
        if all_connected and valid_ontology and single_component and coordinator_maintains:
            print("[PASS] SUCCESS: Graph properly implements ontology as ONE GIANT CONNECTED COMPONENT")
            print("  - All nodes are reachable from root")
            print("  - Edge types follow ontology relationships")
            print("  - Node types match ontology specification")
            print("  - Coordinator maintains connectivity")
            return True
        else:
            print("[FAIL] ISSUES FOUND:")
            if not all_connected:
                print("  - Some nodes are disconnected from main component")
            if not valid_ontology:
                print("  - Ontology violations detected")
            if not single_component:
                print("  - Multiple disconnected components exist")
            if not coordinator_maintains:
                print("  - Coordinator creates disconnected nodes")
            return False
            
    except Exception as e:
        print(f"Test failed with error: {e}")
        import traceback
        traceback.print_exc()
        return False

if __name__ == "__main__":
    success = test_graph_connectivity_and_ontology()
    print(f"\n{'[OK] ALL TESTS PASSED' if success else '[ERROR] TESTS FAILED'}")